# -*- coding: utf-8 -*-
"""utils

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1diF2G6RsGtsY8Hx1Tge7ErW8YIfhMSXB
"""

import numpy as np 
import torch
import torch.nn.functional as F
import matplotlib.pyplot as plt
import os

def class2rgb(out):
  classes = {
    0 : [0,0,0], # unlabeled
    1 : [70,70,70], # building
    2 : [190,153,153], # fence
    3 : [250,170,160], # other
    4 : [220,20,60], # pedestrian
    5 : [153,153,153], # pole
    6 : [157,234,50], # road line
    7 : [128,64,128], # road
    8 : [244,35,232], # sidewalk
    9 : [107,142,35], # vegetation
    10: [0,0,142], # car
    11: [102,102,156], # wall
    12: [220,220,0] # traffic sign
  }
  o = out[...,0]
  seg = o.reshape(-1)
  mask = np.zeros((seg.shape[0],3))
  

  for idx, label in enumerate(seg):
    mask[idx] = classes[int(label)]

  return mask.reshape(out.shape)

def results(img1, img2):
  intersection = np.logical_and(img1,img2)
  union = np.logical_or(img1,img2)
  all_pixels = img1.sum() + img2.sum()
  dice = 2*intersection.sum() / all_pixels
  iou = intersection.sum() / union.sum()
  return dice, iou

def scores(y, out):
  channels = out.shape[1]
  classes = out.argmax(axis = 1)
  denominator = y.shape[0] * channels
  dice = 0
  iou = 0
  for val in range(y.shape[0]):
    y_c = F.one_hot(y[val].to(torch.int64),channels).reshape(channels,256,256)
    p_c = F.one_hot(classes[val].to(torch.int64),channels).reshape(channels,256,256)
    for idx in range(channels):
      d, i = results(p_c.cpu().numpy(), y_c.cpu().numpy())
      dice+=d
      iou+=i
  return dice/denominator, iou/denominator

def save_plot(a1, a2, name, save_path):
  plt.figure(dpi = 170)
  plt.grid()
  plt.plot(a1)
  plt.plot(a2)
  plt.savefig(os.path.join(save_path,name))

def accuracy(y, output):
  batch_acc = []
  for idx in range(y.shape[0]):
    batch_acc.append((y[idx] == output[idx]).sum() / y[idx].flatten().shape[0])
  return np.mean(batch_acc)