# -*- coding: utf-8 -*-
"""utils

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1diF2G6RsGtsY8Hx1Tge7ErW8YIfhMSXB
"""

import numpy as np 
import torch
import torch.nn.functional as F
import matplotlib.pyplot as plt
import os

def results(img1, img2):
  intersection = np.logical_and(img1,img2)
  union = np.logical_or(img1,img2)
  all_pixels = img1.sum() + img2.sum()
  dice = 2*intersection.sum() / all_pixels
  iou = intersection.sum() / union.sum()
  return dice, iou

def scores(y, out):
  channels = out.shape[1]
  classes = out.argmax(axis = 1)
  denominator = y.shape[0] * channels
  dice = 0
  iou = 0
  for val in range(y.shape[0]):
    y_c = F.one_hot(y[val].to(torch.int64),channels).reshape(channels,150,200)
    p_c = F.one_hot(classes[val].to(torch.int64),channels).reshape(channels,150,200)
    for idx in range(channels):
      d, i = results(p_c.cpu().numpy(), y_c.cpu().numpy())
      dice+=d
      iou+=i
  return dice/denominator, iou/denominator

def save_plot(a1, a2, name, save_path):
  plt.figure(dpi = 170)
  plt.grid()
  plt.plot(a1)
  plt.plot(a2)
  plt.savefig(os.path.join(save_path,name))

def accuracy(y, output):
  batch_acc = []
  for idx in range(y.shape[0]):
    batch_acc.append((y[idx] == output[idx]).sum() / y[idx].flatten().shape[0])
  return np.mean(batch_acc)
